/*
  Game Boy Printer tester with Arduino, by Raphaël BOICHOT 2025/05/20
  This code takes control of the Game Boy Printer like a real Game Boy will do
*/

bool bit_sent, bit_read;
bool printer_busy = 0;
bool printer_connected = 0;
byte byte_read, byte_sent;
int clk = 2;  // clock signal
int TX = 3;   // The data signal coming from the Arduino and going to the printer (Sout on Arduino becomes Sin on the printer)
int RX = 4;   // The response bytes coming from printer going to Arduino (Sout from printer becomes Sin on the Arduino)
//invert TX/RX if it does not work, assuming that everything else is OK

// if you modify a command, the checksum bytes must be modified accordingly
const byte INIT[] = { 0x88, 0x33, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 };                    //INT command
byte PRNT[] = { 0x88, 0x33, 0x02, 0x00, 0x04, 0x00, 0x01, 0x00, 0xE4, 0x40, 0x00, 0x00, 0x00, 0x00 };  //PRINT without feed lines, default intensity is 0x40, min is 0x00, max is 0x7F
byte CUST[] = { 0x88, 0x33, 0x06, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };  //PACKET into N64 games
//const byte PRNT[]={0x88,0x33,0x02,0x00,0x04,0x00,0x01,0x00,0xE4,0x00,0xEB,0x00,0x00,0x00}; //PRINT without feed lines, lighter
const byte INQU[] = { 0x88, 0x33, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00 };  //INQUIRY command
const byte EMPT[] = { 0x88, 0x33, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00 };  //Empty data packet, mandatory for validate DATA packet
const byte ABOR[] = { 0x88, 0x33, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00 };  //Empty data packet, mandatory for validate DATA packet

//a 640 bytes packet of data in Game Boy Tile Format for debugging (or more)
byte DATA[] = { 0x88, 0x33, 0x04, 0x00, 0x80, 0x02,  //header
                0xC3, 0xD8, 0xC3, 0xD8, 0xC3, 0xD8, 0xC3, 0xD8, 0xC3, 0xD8, 0xC3, 0xD8, 0xC3, 0xD8, 0xC3, 0xD8,
                0x18, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x18, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x18, 0x00, 0x3C,
                0xC0, 0xC0, 0x06, 0x00, 0x06, 0x00, 0xC0, 0x00, 0xE0, 0x00, 0xE0, 0x00, 0xC0, 0x00, 0x00, 0x06,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x01, 0x01, 0x03, 0x02, 0x07, 0x04,
                0x0E, 0x0F, 0x1F, 0x31, 0x3E, 0x60, 0x7D, 0xC0, 0xF9, 0x84, 0xF3, 0x0F, 0xEF, 0x1F, 0xF8, 0x34,
                0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0xF0, 0xF0, 0xF8, 0xF8, 0xF8, 0xF8, 0x80, 0x80,
                0x00, 0x05, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10,
                0x00, 0x55, 0x00, 0x00, 0xFF, 0xFF, 0xFE, 0x9C, 0xBE, 0xDC, 0xFE, 0x9C, 0xBE, 0xDC, 0xFE, 0x80,
                0x00, 0x55, 0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xC0, 0xCF, 0xCF, 0xDF, 0xD8, 0xDF, 0xD3, 0xD7, 0xDB,
                0x00, 0x55, 0x00, 0x00, 0x07, 0x07, 0x07, 0x04, 0xE7, 0xE6, 0xF7, 0x76, 0xB3, 0x32, 0xB3, 0x32,
                0x00, 0x55, 0x00, 0x00, 0xE7, 0xE7, 0x67, 0x64, 0x67, 0x66, 0x67, 0x66, 0x63, 0x62, 0x63, 0x62,
                0x00, 0x55, 0x00, 0x00, 0xE0, 0xE0, 0x60, 0x60, 0x63, 0x63, 0x67, 0x66, 0x67, 0x64, 0x65, 0x66,
                0x00, 0x55, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0xF9, 0xF9, 0xFD, 0x1D, 0xED, 0xCD, 0xED, 0xCD,
                0x00, 0x55, 0x00, 0x00, 0xF0, 0xF0, 0xB0, 0x30, 0xB0, 0x30, 0xB0, 0x30, 0xB0, 0x30, 0xB0, 0x30,
                0x00, 0x00, 0x01, 0x41, 0x02, 0x02, 0x02, 0x42, 0x02, 0x02, 0x02, 0x42, 0x02, 0x02, 0x02, 0x42,
                0xFE, 0xFE, 0x83, 0xFF, 0xFE, 0x82, 0x82, 0xFE, 0xFE, 0xFE, 0x82, 0xFE, 0xFE, 0xFE, 0x82, 0xFE,
                0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0xE2, 0x80, 0xE0, 0x80, 0xE0, 0x80, 0xE0, 0x80,
                0x03, 0x00, 0x00, 0x60, 0x00, 0x60, 0x00, 0x03, 0x00, 0x07, 0x00, 0x07, 0x00, 0x03, 0x60, 0x60,
                0x00, 0x18, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x18, 0x00, 0x80, 0x00, 0x80, 0x18, 0x18, 0x3C, 0x3C,
                0xC3, 0x1B, 0xC3, 0x1B, 0xC3, 0x1B, 0xC3, 0x1B, 0xC3, 0x1B, 0xC3, 0x1B, 0xC3, 0x1B, 0xC3, 0x1B,
                0xC3, 0xD8, 0xC3, 0xD8, 0xC3, 0xD8, 0xC3, 0xD8, 0xC3, 0xD8, 0xC3, 0xD8, 0xC3, 0xD8, 0xC3, 0xD8,
                0x00, 0x3C, 0x00, 0x18, 0x00, 0x01, 0x00, 0x01, 0x18, 0x18, 0x3C, 0x3C, 0x3C, 0x3C, 0x18, 0x18,
                0x00, 0x06, 0x00, 0xC0, 0x00, 0xE0, 0x00, 0xE0, 0x00, 0xC0, 0x06, 0x06, 0x06, 0x06, 0xC0, 0xC0,
                0x07, 0x04, 0x05, 0x07, 0x07, 0x07, 0x43, 0x03, 0x01, 0x03, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00,
                0xFD, 0xE1, 0xFD, 0xF1, 0xCF, 0xF0, 0xFD, 0xCE, 0xFF, 0xAF, 0xBF, 0xC3, 0x7F, 0xE0, 0x1F, 0x3F,
                0xE0, 0xE0, 0x70, 0x98, 0xF8, 0x08, 0xF0, 0x18, 0xE0, 0xF0, 0x80, 0xC5, 0x80, 0x80, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x15,
                0xBE, 0xDC, 0xFE, 0x9C, 0xBE, 0xDC, 0xFE, 0x9C, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x55,
                0xDF, 0xD0, 0xD7, 0xDB, 0xDF, 0xD3, 0xDF, 0xD8, 0xDF, 0xDF, 0xCF, 0xCF, 0x00, 0x00, 0x00, 0x55,
                0xB3, 0x32, 0xF3, 0xF2, 0x33, 0x32, 0x73, 0x72, 0xF3, 0xF3, 0xE3, 0xE3, 0x00, 0x00, 0x00, 0x55,
                0x63, 0x62, 0x63, 0x62, 0x63, 0x62, 0x63, 0x62, 0xE3, 0xE3, 0xE3, 0xE3, 0x00, 0x00, 0x00, 0x55,
                0x67, 0x64, 0x65, 0x66, 0x67, 0x64, 0x67, 0x66, 0xE7, 0xE7, 0xE3, 0xE3, 0x00, 0x00, 0x00, 0x55,
                0xED, 0xCD, 0xED, 0xCD, 0xED, 0xCD, 0xFD, 0x1D, 0xFD, 0xFD, 0xF9, 0xF9, 0x00, 0x00, 0x00, 0x55,
                0xB0, 0x30, 0xB0, 0x30, 0xF0, 0xF0, 0xB0, 0x30, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x55,
                0x02, 0x02, 0x02, 0x42, 0x02, 0x02, 0x02, 0x42, 0x02, 0x02, 0x02, 0x42, 0x03, 0x03, 0x00, 0x40,
                0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x06, 0xC0, 0x06, 0xC0, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
                0xE0, 0x80, 0xE0, 0x80, 0xE0, 0x80, 0xE2, 0x80, 0xE0, 0x80, 0xE0, 0x80, 0xE0, 0x80, 0xE0, 0x00,
                0x60, 0x60, 0x03, 0x03, 0x07, 0x07, 0x07, 0x07, 0x03, 0x03, 0x60, 0x00, 0x60, 0x00, 0x03, 0x00,
                0x3C, 0x3C, 0x18, 0x18, 0x80, 0x80, 0x80, 0x80, 0x18, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x18, 0x00,
                0xC3, 0x1B, 0xC3, 0x1B, 0xC3, 0x1B, 0xC3, 0x1B, 0xC3, 0x1B, 0xC3, 0x1B, 0xC3, 0x1B, 0xC3, 0x1B,
                0x00, 0x00, 0x00, 0x00 };  //footer

//a 320 bytes packet of data in Game Boy Tile Format for debugging (or more)
byte half_DATA[] = { 0x88, 0x33, 0x04, 0x00, 0x40, 0x01,  //header
                     0x00, 0x00, 0x00, 0x00, 0x3E, 0x3E, 0x03, 0x03, 0x3F, 0x3F, 0x63, 0x63, 0x3F, 0x3F, 0x00, 0x00,
                     0x60, 0x60, 0x60, 0x60, 0x7E, 0x7E, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x7E, 0x7E, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x3E, 0x3E, 0x63, 0x63, 0x60, 0x60, 0x63, 0x63, 0x3E, 0x3E, 0x00, 0x00,
                     0x03, 0x03, 0x03, 0x03, 0x3F, 0x3F, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x3F, 0x3F, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x3E, 0x3E, 0x63, 0x63, 0x7F, 0x7F, 0x60, 0x60, 0x3E, 0x3E, 0x00, 0x00,
                     0x1E, 0x1E, 0x18, 0x18, 0x7F, 0x7F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x63, 0x63, 0x3F, 0x3F, 0x03, 0x03, 0x3E, 0x3E, 0x00, 0x00,
                     0x60, 0x60, 0x60, 0x60, 0x7E, 0x7E, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x00, 0x00,
                     0x0C, 0x0C, 0x00, 0x00, 0x3C, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x7F, 0x7F, 0x00, 0x00,
                     0x03, 0x03, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x63, 0x63, 0x3E, 0x3E, 0x00, 0x00,
                     0x60, 0x60, 0x60, 0x60, 0x63, 0x63, 0x66, 0x66, 0x7C, 0x7C, 0x66, 0x66, 0x63, 0x63, 0x00, 0x00,
                     0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x38, 0x38, 0x0F, 0x0F, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x3E, 0x3E, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x3E, 0x3E, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x63, 0x63, 0x7E, 0x7E, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x63, 0x63, 0x3F, 0x3F, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x6E, 0x6E, 0x73, 0x73, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x60, 0x60, 0x7F, 0x7F, 0x03, 0x03, 0x7E, 0x7E, 0x00, 0x00,
                     0x18, 0x18, 0x18, 0x18, 0x7F, 0x7F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x1F, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x00 };  //footer

void setup() {
  pinMode(clk, OUTPUT);
  pinMode(TX, OUTPUT);
  pinMode(RX, INPUT_PULLUP);
  digitalWrite(clk, HIGH);
  digitalWrite(TX, LOW);
  // Open serial communications and wait for port to open:
  Serial.begin(115200);
  // wait for Serial Monitor to connect. Needed for native USB port boards only:
  while (!Serial)
    ;

  /*Comment next section if your printer struggle to connect, it is just for fun here
This issue can happen with some printer emulator but real printer is OK with that*/
  Serial.println();
  Serial.print(F("Trying to ping the printer"));
  while (!(printer_connected)) {
    delay(500);
    Serial.println();
    Serial.print(F("INIT packet sent -->"));
    sequence(INIT, 10);  // here we send the INIT command until we get 0x81 at byte 9, printer connected
    if (!(printer_connected)) {
      Serial.print(F(" / Printer not responding"));
    }
  }
  Serial.print(F(" / Printer connected !"));

  Serial.println();
  Serial.print(F("Updating DATA packet checksum"));
  update_checksum(DATA, 2, 645, 646);
  Serial.println();
  Serial.print(F("DATA packet sent -->"));
  sequence(DATA, 650);  //here we send the data packet to the printer
  //update_checksum(half_DATA, 2, 315, 316);  //here we send the data packet to the printer
  Serial.println();
  Serial.print(F("EMPT packet sent -->"));
  sequence(EMPT, 10);  // here we send a mandatory empty packet
  Serial.println();
  Serial.print(F("PRNT packet sent -->"));
  update_checksum(PRNT, 2, 9, 10);
  sequence(PRNT, 14);  // here we send the last printing command
  printing_loop();
  digitalWrite(clk, LOW);
  digitalWrite(TX, LOW);
  Serial.println();
  Serial.println(F("End of transmission, reboot Arduino to restart"));
}
///////////////////////////////////////////////////////////end of printing section

void loop() {
  // empty, the code is just ran one time
}

void printing_loop() {
  printer_busy = 1;       //to enter the loop
  delay(200);             //printer is not immediately busy
  while (printer_busy) {  //call iquiry until not busy
    Serial.println();
    Serial.print(F("INQU packet sent -->"));
    printer_busy = 0;
    sequence(INQU, 10);
    delay(200);
  }
  Serial.println();
  Serial.print(F("Printer not busy !"));
}

void sequence(byte packet[], int sequence_length) {
  for (int i = 0; i <= sequence_length - 1; i++) {
    int verbose_mode = (i == sequence_length - 1) ? 1 : -1;
    int connected_mode = (i == sequence_length - 2) ? 1 : -1;
    int mode = ((i == sequence_length - 1) || (i == sequence_length - 2)) ? 2 : 1;
    printing(packet[i], mode, verbose_mode, connected_mode);
  }
}

void printing(int byte_sent, int mode, int verbose_mode, int connected_mode) {  // this function prints bytes to the serial
  for (int j = 0; j <= 7; j++) {
    bit_sent = bitRead(byte_sent, 7 - j);
    digitalWrite(clk, LOW);
    digitalWrite(TX, bit_sent);
    delayMicroseconds(30);  //double speed mode
    digitalWrite(clk, HIGH);
    bit_read = (digitalRead(RX));
    bitWrite(byte_read, 7 - j, bit_read);
    delayMicroseconds(30);  //double speed mode
  }
  delayMicroseconds(0);  //optionnal delay between bytes, may me less than 1490 µs
  if (mode == 1) {
    if (byte_sent <= 0x0F) {
      Serial.print('0');
    }
    Serial.print(byte_sent, HEX);
    Serial.print(' ');
  }
  if (mode == 2) {
    if (byte_read <= 0x0F) {
      Serial.print('0');
    }
    Serial.print(byte_read, HEX);
    Serial.print(' ');
  }

  if (connected_mode == 1) {
    printer_connected = 0;
    if (byte_read == 0x81) {
      printer_connected = 1;
    };
  }

  if (verbose_mode == 1) {
    Serial.print("--> ");
    for (int m = 0; m <= 7; m++) {
      Serial.print(bitRead(byte_read, 7 - m));
    }

    if (bitRead(byte_read, 0)) {
      Serial.print(F(" / Checksum error"));
    }

    printer_busy = 0;
    if (bitRead(byte_read, 1)) {
      printer_busy = 1;
      Serial.print(F(" / Printer busy"));
    }

    if (bitRead(byte_read, 2)) {
      Serial.print(F(" / Image data full"));
    }

    if (bitRead(byte_read, 3)) {
      Serial.print(F(" / Unprocessed data"));
    }

    if (bitRead(byte_read, 4)) {
      Serial.print(F(" / Packet error"));
    }

    if (bitRead(byte_read, 5)) {
      Serial.print(F(" / Paper jam"));
    }

    if (bitRead(byte_read, 6)) {
      Serial.print(F(" / Other error"));
    }

    if (bitRead(byte_read, 7)) {
      Serial.print(F(" / Low battery"));
    }
  }
}

//checksum is always from the third to the last-4 bytes
void update_checksum(byte* packet, int start_index, int end_index, int checksum_pos) {
  word checksum = 0;
  for (int i = start_index; i <= end_index; i++) {
    checksum += packet[i];
  }
  packet[checksum_pos] = checksum & 0x00FF;  // low byte
  packet[checksum_pos + 1] = checksum >> 8;  // high byte
}